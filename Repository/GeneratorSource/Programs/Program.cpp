/*  Parent Class for all Programs
 *
 *  From: https://github.com/Mysticial/Pokemon-Automation-SwSh-Arduino-Scripts
 *
 */

#include <iostream>
using std::cout;
using std::endl;

#include <QJsonArray>
#include <QDir>
#include <QFile>
#include <QLayout>
#include <QVBoxLayout>
#include <QLabel>
#include <QPushButton>
#include <QMessageBox>
#include "Tools/Tools.h"
#include "Tools/PersistentSettings.h"
#include "Dialogs/MainWindow.h"
#include "Program.h"

const QString Program::JSON_PROGRAM_NAME    = "0-ProgramName";
const QString Program::JSON_DESCRIPTION     = "1-Description";
const QString Program::JSON_PARAMETERS      = "2-Parameters";

Program::Program(const QString& name, const QString& description)
    : m_name(name)
    , m_description(description)
{}
Program::Program(const QJsonObject& obj)
    : m_name(json_get_string(obj, JSON_PROGRAM_NAME))
    , m_description(json_get_string(obj, JSON_DESCRIPTION))
{}

QWidget* Program::make_options_body(QWidget& parent){
    QWidget* box = new QWidget(&parent);
    QVBoxLayout* layout = new QVBoxLayout(box);
    QLabel* label = new QLabel("There are no program-specific options for this program.");
    label->setAlignment(Qt::AlignCenter);
    layout->addWidget(label);
    return box;
}

QJsonDocument Program::to_json() const{
    QJsonObject root;
    root.insert(JSON_PROGRAM_NAME, m_name);
    root.insert(JSON_DESCRIPTION, m_description);
    root.insert(JSON_PARAMETERS, parameters_json());
    return QJsonDocument(root);
}
std::string Program::to_cfile() const{
    std::string body;
    body += "//  This file is generated by the UI. There's no point in editing.\r\n";
    body += "#include \"";
    body += "../DeviceSource/PokemonSwShPrograms/";
    body += m_name.toUtf8().data();
    body += ".h\"\r\n";
    body += parameters_cpp();
    return body;
}
QString Program::save_json() const{
    QString name = settings.config_path + "/" + m_name + ".json";
    write_json_file(name, to_json());
    return name;
}
QString Program::save_cfile() const{
    QString name = settings.source_path + "/" + m_name + ".c";
    std::string cpp = to_cfile();
    QFile file(name);
    if (!file.open(QFile::WriteOnly)){
        throw "Unable to create source file: " + name;
    }
    if (file.write(cpp.c_str(), cpp.size()) != cpp.size()){
        throw "Unable to write source file: " + name;
    }
    file.close();
    return name;
}
void Program::save_and_build(const std::string& mcu){
//        cout << "asdf" << endl;
    if (!is_valid()){
        QMessageBox box;
        box.critical(nullptr, "Error", "The current settings are invalid.");
        return;
    }
    if (!QDir(settings.config_path).exists()){
        QMessageBox box;
        box.critical(nullptr, "Error", "Source directory not found. Please unzip the package if you haven't already.");
        return;
    }

    try{
        save_json();
        save_cfile();
    }catch (const char* str){
        QMessageBox box;
        box.critical(nullptr, "Error", str);
        return;
    }catch (const QString& str){
        QMessageBox box;
        box.critical(nullptr, "Error", str);
        return;
    }

    build_hexfile(mcu, m_name.toUtf8().data());

    if (QFileInfo(m_name + "-" + mcu.c_str() + ".hex").exists()){
        QMessageBox box;
        box.information(nullptr, "Success!", ".hex file has been built!");
    }else{
        QMessageBox box;
        box.critical(nullptr, "Error", ".hex was not built. Please check error log.");
    }
}

QWidget* Program::make_ui(MainWindow& parent){
    QWidget* box = new QWidget(&parent);
    QVBoxLayout* layout = new QVBoxLayout(box);
    layout->setMargin(0);
//    layout->setAlignment(Qt::AlignTop);
    layout->addWidget(new QLabel("<font size=4><b>Name:</b></font> " + m_name));
    {
        QLabel* text = new QLabel("<font size=4><b>Description:</b></font> " + m_description);
        layout->addWidget(text);
        text->setWordWrap(true);
    }
    {
        QString path = GITHUB_REPO + "/blob/master/Documentation/Programs/" + m_name + ".md";
        QLabel* text = new QLabel("<font size=4><a href=\"" + path + "\">Online Documentation for " + m_name + "</a></font>");
        layout->addWidget(text);
        text->setTextFormat(Qt::RichText);
        text->setTextInteractionFlags(Qt::TextBrowserInteraction);
        text->setOpenExternalLinks(true);
    }
    layout->addWidget(make_options_body(*box), Qt::AlignBottom);

    QHBoxLayout* row = new QHBoxLayout();
    layout->addLayout(row);
    {
        QPushButton* button = new QPushButton("Save Settings", box);
        connect(
            button, &QPushButton::clicked,
            this, [&](bool){
                try{
                    QString name = save_json();
                    QMessageBox box;
                    box.information(nullptr, "Success!", "Settings saved to: " + name + "\n");
                }catch (const char* str){
                    QMessageBox box;
                    box.critical(nullptr, "Error", str);
                    return;
                }catch (const QString& str){
                    QMessageBox box;
                    box.critical(nullptr, "Error", str);
                    return;
                }
            }
        );
        row->addWidget(button);
    }
    {
        QPushButton* button = new QPushButton("Restore Defaults", box);
        connect(
            button, &QPushButton::clicked,
            this, [&](bool){
                restore_defaults();
                parent.replace_active_program(*this);
            }
        );
        row->addWidget(button);
    }
    {
        QPushButton* button = new QPushButton("Save and generate .hex file!", box);
        QFont font = button->font();
        font.setPointSize(16);
        button->setFont(font);
        connect(
            button, &QPushButton::clicked,
            this, [&](bool){
                save_and_build(parent.current_MCU());
            }
        );
        layout->addWidget(button);
    }
    return box;
}


